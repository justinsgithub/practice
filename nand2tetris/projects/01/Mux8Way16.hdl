// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/01/Mux8Way16.hdl
/**
 * 8-way 16-bit multiplexor:
 * out = a if sel == 000
 *       b if sel == 001
 *       ...
 *       h if sel == 111
|        a         |        b         |        c         |        d         |        e         |        f         |        g         |        h         |  sel  |       out        |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  000  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  001  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  010  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  011  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  100  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  101  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  110  | 0000000000000000 |
| 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 | 0000000000000000 |  111  | 0000000000000000 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  000  | 0001001000110100 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  001  | 0010001101000101 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  010  | 0011010001010110 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  011  | 0100010101100111 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  100  | 0101011001111000 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  101  | 0110011110001001 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  110  | 0111100010011010 |
| 0001001000110100 | 0010001101000101 | 0011010001010110 | 0100010101100111 | 0101011001111000 | 0110011110001001 | 0111100010011010 | 1000100110101011 |  111  | 1000100110101011 |

 * h == 111
 * g == 110
 * f == 101
 * e == 100
 * d == 011
 * c == 010
 * b == 001
 * a == 000
 */
CHIP Mux8Way16 {
    IN a[16], b[16], c[16], d[16], e[16], f[16], g[16], h[16], sel[3];
    OUT out[16];

    PARTS:
    And(a=sel[0], b=sel[0], out=s3);
    And(a=sel[1], b=sel[1], out=s2);
    And(a=sel[2], b=sel[2], out=s1);

    Not(in=s1, out=ns1);
    Not(in=s2, out=ns2);
    Not(in=s3, out=ns3);

    And(a=s2, b=s3, out=s2s3);
    And(a=s1, b=s2, out=s1s2);
    And(a=s1, b=s3, out=s1s3);

    And(a=ns1, b=ns3, out=ns1ns3);
    And(a=ns2, b=ns3, out=ns2ns3);
    And(a=ns1, b=ns2, out=ns1ns2);

    And(a=s1s2, b=s3, out=s1s2s3); /* h */
    And(a=s1s2, b=ns3, out=s1s2ns3); /* g */
    And(a=s1s3, b=ns2, out=s1ns2s3); /* f */
    And(a=s1, b=ns2ns3, out=s1ns2ns3); /* e */
    And(a=ns1, b=s2s3, out=ns1s2s3); /* d */
    And(a=s2, b=ns1ns3, out=s2ns1ns3); /* c */
    And(a=s3, b=ns1ns2, out=ns1ns2s3); /* b */
    And(a=ns1, b=ns2ns3, out=ns1ns2ns3); /* a */

    Mux16(a=g, b=h, sel=s1s2s3, out=out1);
    Mux16(a=out1, b=g, sel=s1s2ns3, out=out2);
    Mux16(a=out2, b=f, sel=s1ns2s3, out=out3);
    Mux16(a=out3, b=e, sel=s1ns2ns3, out=out4);
    Mux16(a=out4, b=d, sel=ns1s2s3, out=out5);
    Mux16(a=out5, b=c, sel=s2ns1ns3, out=out6);
    Mux16(a=out6, b=b, sel=ns1ns2s3, out=out7);
    Mux16(a=out7, b=a, sel=ns1ns2ns3, out=out);
}
